import $n, { createContext as Mr, useContext as Fr } from "react";
var ot = { exports: {} }, qe = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dn;
function Lr() {
  if (dn) return qe;
  dn = 1;
  var e = $n, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(c, a, u) {
    var d, h = {}, f = null, g = null;
    u !== void 0 && (f = "" + u), a.key !== void 0 && (f = "" + a.key), a.ref !== void 0 && (g = a.ref);
    for (d in a) r.call(a, d) && !o.hasOwnProperty(d) && (h[d] = a[d]);
    if (c && c.defaultProps) for (d in a = c.defaultProps, a) h[d] === void 0 && (h[d] = a[d]);
    return { $$typeof: t, type: c, key: f, ref: g, props: h, _owner: i.current };
  }
  return qe.Fragment = n, qe.jsx = s, qe.jsxs = s, qe;
}
var ze = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hn;
function Dr() {
  return hn || (hn = 1, process.env.NODE_ENV !== "production" && function() {
    var e = $n, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), a = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), b = Symbol.iterator, E = "@@iterator";
    function S(l) {
      if (l === null || typeof l != "object")
        return null;
      var p = b && l[b] || l[E];
      return typeof p == "function" ? p : null;
    }
    var w = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(l) {
      {
        for (var p = arguments.length, v = new Array(p > 1 ? p - 1 : 0), x = 1; x < p; x++)
          v[x - 1] = arguments[x];
        O("error", l, v);
      }
    }
    function O(l, p, v) {
      {
        var x = w.ReactDebugCurrentFrame, P = x.getStackAddendum();
        P !== "" && (p += "%s", v = v.concat([P]));
        var I = v.map(function(C) {
          return String(C);
        });
        I.unshift("Warning: " + p), Function.prototype.apply.call(console[l], console, I);
      }
    }
    var y = !1, m = !1, R = !1, D = !1, K = !1, W;
    W = Symbol.for("react.module.reference");
    function X(l) {
      return !!(typeof l == "string" || typeof l == "function" || l === r || l === o || K || l === i || l === u || l === d || D || l === g || y || m || R || typeof l == "object" && l !== null && (l.$$typeof === f || l.$$typeof === h || l.$$typeof === s || l.$$typeof === c || l.$$typeof === a || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      l.$$typeof === W || l.getModuleId !== void 0));
    }
    function $(l, p, v) {
      var x = l.displayName;
      if (x)
        return x;
      var P = p.displayName || p.name || "";
      return P !== "" ? v + "(" + P + ")" : v;
    }
    function A(l) {
      return l.displayName || "Context";
    }
    function F(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case c:
            var p = l;
            return A(p) + ".Consumer";
          case s:
            var v = l;
            return A(v._context) + ".Provider";
          case a:
            return $(l, l.render, "ForwardRef");
          case h:
            var x = l.displayName || null;
            return x !== null ? x : F(l.type) || "Memo";
          case f: {
            var P = l, I = P._payload, C = P._init;
            try {
              return F(C(I));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var L = Object.assign, V = 0, N, ne, fe, Q, Y, re, et;
    function Kt() {
    }
    Kt.__reactDisabledLog = !0;
    function sr() {
      {
        if (V === 0) {
          N = console.log, ne = console.info, fe = console.warn, Q = console.error, Y = console.group, re = console.groupCollapsed, et = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: Kt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        V++;
      }
    }
    function lr() {
      {
        if (V--, V === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: L({}, l, {
              value: N
            }),
            info: L({}, l, {
              value: ne
            }),
            warn: L({}, l, {
              value: fe
            }),
            error: L({}, l, {
              value: Q
            }),
            group: L({}, l, {
              value: Y
            }),
            groupCollapsed: L({}, l, {
              value: re
            }),
            groupEnd: L({}, l, {
              value: et
            })
          });
        }
        V < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var bt = w.ReactCurrentDispatcher, yt;
    function tt(l, p, v) {
      {
        if (yt === void 0)
          try {
            throw Error();
          } catch (P) {
            var x = P.stack.trim().match(/\n( *(at )?)/);
            yt = x && x[1] || "";
          }
        return `
` + yt + l;
      }
    }
    var wt = !1, nt;
    {
      var cr = typeof WeakMap == "function" ? WeakMap : Map;
      nt = new cr();
    }
    function Xt(l, p) {
      if (!l || wt)
        return "";
      {
        var v = nt.get(l);
        if (v !== void 0)
          return v;
      }
      var x;
      wt = !0;
      var P = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var I;
      I = bt.current, bt.current = null, sr();
      try {
        if (p) {
          var C = function() {
            throw Error();
          };
          if (Object.defineProperty(C.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(C, []);
            } catch (z) {
              x = z;
            }
            Reflect.construct(l, [], C);
          } else {
            try {
              C.call();
            } catch (z) {
              x = z;
            }
            l.call(C.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (z) {
            x = z;
          }
          l();
        }
      } catch (z) {
        if (z && x && typeof z.stack == "string") {
          for (var T = z.stack.split(`
`), q = x.stack.split(`
`), j = T.length - 1, B = q.length - 1; j >= 1 && B >= 0 && T[j] !== q[B]; )
            B--;
          for (; j >= 1 && B >= 0; j--, B--)
            if (T[j] !== q[B]) {
              if (j !== 1 || B !== 1)
                do
                  if (j--, B--, B < 0 || T[j] !== q[B]) {
                    var ee = `
` + T[j].replace(" at new ", " at ");
                    return l.displayName && ee.includes("<anonymous>") && (ee = ee.replace("<anonymous>", l.displayName)), typeof l == "function" && nt.set(l, ee), ee;
                  }
                while (j >= 1 && B >= 0);
              break;
            }
        }
      } finally {
        wt = !1, bt.current = I, lr(), Error.prepareStackTrace = P;
      }
      var Ie = l ? l.displayName || l.name : "", Ee = Ie ? tt(Ie) : "";
      return typeof l == "function" && nt.set(l, Ee), Ee;
    }
    function ar(l, p, v) {
      return Xt(l, !1);
    }
    function ur(l) {
      var p = l.prototype;
      return !!(p && p.isReactComponent);
    }
    function rt(l, p, v) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Xt(l, ur(l));
      if (typeof l == "string")
        return tt(l);
      switch (l) {
        case u:
          return tt("Suspense");
        case d:
          return tt("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case a:
            return ar(l.render);
          case h:
            return rt(l.type, p, v);
          case f: {
            var x = l, P = x._payload, I = x._init;
            try {
              return rt(I(P), p, v);
            } catch {
            }
          }
        }
      return "";
    }
    var Ue = Object.prototype.hasOwnProperty, Gt = {}, Zt = w.ReactDebugCurrentFrame;
    function it(l) {
      if (l) {
        var p = l._owner, v = rt(l.type, l._source, p ? p.type : null);
        Zt.setExtraStackFrame(v);
      } else
        Zt.setExtraStackFrame(null);
    }
    function fr(l, p, v, x, P) {
      {
        var I = Function.call.bind(Ue);
        for (var C in l)
          if (I(l, C)) {
            var T = void 0;
            try {
              if (typeof l[C] != "function") {
                var q = Error((x || "React class") + ": " + v + " type `" + C + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[C] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw q.name = "Invariant Violation", q;
              }
              T = l[C](p, C, x, v, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (j) {
              T = j;
            }
            T && !(T instanceof Error) && (it(P), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", x || "React class", v, C, typeof T), it(null)), T instanceof Error && !(T.message in Gt) && (Gt[T.message] = !0, it(P), _("Failed %s type: %s", v, T.message), it(null));
          }
      }
    }
    var dr = Array.isArray;
    function _t(l) {
      return dr(l);
    }
    function hr(l) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, v = p && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return v;
      }
    }
    function pr(l) {
      try {
        return Qt(l), !1;
      } catch {
        return !0;
      }
    }
    function Qt(l) {
      return "" + l;
    }
    function en(l) {
      if (pr(l))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", hr(l)), Qt(l);
    }
    var tn = w.ReactCurrentOwner, gr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, nn, rn;
    function mr(l) {
      if (Ue.call(l, "ref")) {
        var p = Object.getOwnPropertyDescriptor(l, "ref").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return l.ref !== void 0;
    }
    function vr(l) {
      if (Ue.call(l, "key")) {
        var p = Object.getOwnPropertyDescriptor(l, "key").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return l.key !== void 0;
    }
    function br(l, p) {
      typeof l.ref == "string" && tn.current;
    }
    function yr(l, p) {
      {
        var v = function() {
          nn || (nn = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        v.isReactWarning = !0, Object.defineProperty(l, "key", {
          get: v,
          configurable: !0
        });
      }
    }
    function wr(l, p) {
      {
        var v = function() {
          rn || (rn = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        v.isReactWarning = !0, Object.defineProperty(l, "ref", {
          get: v,
          configurable: !0
        });
      }
    }
    var _r = function(l, p, v, x, P, I, C) {
      var T = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: l,
        key: p,
        ref: v,
        props: C,
        // Record the component responsible for creating this element.
        _owner: I
      };
      return T._store = {}, Object.defineProperty(T._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(T, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: x
      }), Object.defineProperty(T, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: P
      }), Object.freeze && (Object.freeze(T.props), Object.freeze(T)), T;
    };
    function Er(l, p, v, x, P) {
      {
        var I, C = {}, T = null, q = null;
        v !== void 0 && (en(v), T = "" + v), vr(p) && (en(p.key), T = "" + p.key), mr(p) && (q = p.ref, br(p, P));
        for (I in p)
          Ue.call(p, I) && !gr.hasOwnProperty(I) && (C[I] = p[I]);
        if (l && l.defaultProps) {
          var j = l.defaultProps;
          for (I in j)
            C[I] === void 0 && (C[I] = j[I]);
        }
        if (T || q) {
          var B = typeof l == "function" ? l.displayName || l.name || "Unknown" : l;
          T && yr(C, B), q && wr(C, B);
        }
        return _r(l, T, q, P, x, tn.current, C);
      }
    }
    var Et = w.ReactCurrentOwner, on = w.ReactDebugCurrentFrame;
    function ke(l) {
      if (l) {
        var p = l._owner, v = rt(l.type, l._source, p ? p.type : null);
        on.setExtraStackFrame(v);
      } else
        on.setExtraStackFrame(null);
    }
    var xt;
    xt = !1;
    function St(l) {
      return typeof l == "object" && l !== null && l.$$typeof === t;
    }
    function sn() {
      {
        if (Et.current) {
          var l = F(Et.current.type);
          if (l)
            return `

Check the render method of \`` + l + "`.";
        }
        return "";
      }
    }
    function xr(l) {
      return "";
    }
    var ln = {};
    function Sr(l) {
      {
        var p = sn();
        if (!p) {
          var v = typeof l == "string" ? l : l.displayName || l.name;
          v && (p = `

Check the top-level render call using <` + v + ">.");
        }
        return p;
      }
    }
    function cn(l, p) {
      {
        if (!l._store || l._store.validated || l.key != null)
          return;
        l._store.validated = !0;
        var v = Sr(p);
        if (ln[v])
          return;
        ln[v] = !0;
        var x = "";
        l && l._owner && l._owner !== Et.current && (x = " It was passed a child from " + F(l._owner.type) + "."), ke(l), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', v, x), ke(null);
      }
    }
    function an(l, p) {
      {
        if (typeof l != "object")
          return;
        if (_t(l))
          for (var v = 0; v < l.length; v++) {
            var x = l[v];
            St(x) && cn(x, p);
          }
        else if (St(l))
          l._store && (l._store.validated = !0);
        else if (l) {
          var P = S(l);
          if (typeof P == "function" && P !== l.entries)
            for (var I = P.call(l), C; !(C = I.next()).done; )
              St(C.value) && cn(C.value, p);
        }
      }
    }
    function Or(l) {
      {
        var p = l.type;
        if (p == null || typeof p == "string")
          return;
        var v;
        if (typeof p == "function")
          v = p.propTypes;
        else if (typeof p == "object" && (p.$$typeof === a || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        p.$$typeof === h))
          v = p.propTypes;
        else
          return;
        if (v) {
          var x = F(p);
          fr(v, l.props, "prop", x, l);
        } else if (p.PropTypes !== void 0 && !xt) {
          xt = !0;
          var P = F(p);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", P || "Unknown");
        }
        typeof p.getDefaultProps == "function" && !p.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Rr(l) {
      {
        for (var p = Object.keys(l.props), v = 0; v < p.length; v++) {
          var x = p[v];
          if (x !== "children" && x !== "key") {
            ke(l), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", x), ke(null);
            break;
          }
        }
        l.ref !== null && (ke(l), _("Invalid attribute `ref` supplied to `React.Fragment`."), ke(null));
      }
    }
    var un = {};
    function fn(l, p, v, x, P, I) {
      {
        var C = X(l);
        if (!C) {
          var T = "";
          (l === void 0 || typeof l == "object" && l !== null && Object.keys(l).length === 0) && (T += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var q = xr();
          q ? T += q : T += sn();
          var j;
          l === null ? j = "null" : _t(l) ? j = "array" : l !== void 0 && l.$$typeof === t ? (j = "<" + (F(l.type) || "Unknown") + " />", T = " Did you accidentally export a JSX literal instead of a component?") : j = typeof l, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", j, T);
        }
        var B = Er(l, p, v, P, I);
        if (B == null)
          return B;
        if (C) {
          var ee = p.children;
          if (ee !== void 0)
            if (x)
              if (_t(ee)) {
                for (var Ie = 0; Ie < ee.length; Ie++)
                  an(ee[Ie], l);
                Object.freeze && Object.freeze(ee);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              an(ee, l);
        }
        if (Ue.call(p, "key")) {
          var Ee = F(l), z = Object.keys(p).filter(function(Ir) {
            return Ir !== "key";
          }), Ot = z.length > 0 ? "{key: someKey, " + z.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!un[Ee + Ot]) {
            var kr = z.length > 0 ? "{" + z.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ot, Ee, kr, Ee), un[Ee + Ot] = !0;
          }
        }
        return l === r ? Rr(B) : Or(B), B;
      }
    }
    function Tr(l, p, v) {
      return fn(l, p, v, !0);
    }
    function Cr(l, p, v) {
      return fn(l, p, v, !1);
    }
    var Ar = Cr, Pr = Tr;
    ze.Fragment = r, ze.jsx = Ar, ze.jsxs = Pr;
  }()), ze;
}
var pn;
function jr() {
  return pn || (pn = 1, process.env.NODE_ENV === "production" ? ot.exports = Lr() : ot.exports = Dr()), ot.exports;
}
var Hr = jr();
/*! shepherd.js 14.5.0 */
function $r(e) {
  return e instanceof Element;
}
function He(e) {
  return e instanceof HTMLElement;
}
function ve(e) {
  return typeof e == "function";
}
function Ke(e) {
  return typeof e == "string";
}
function U(e) {
  return e === void 0;
}
class Ft {
  /**
   * Adds an event listener for the given event string.
   *
   * @param {string} event
   * @param {Function} handler
   * @param ctx
   * @param {boolean} once
   * @returns
   */
  on(t, n, r, i = !1) {
    var o;
    return U(this.bindings) && (this.bindings = {}), U(this.bindings[t]) && (this.bindings[t] = []), (o = this.bindings[t]) == null || o.push({
      handler: n,
      ctx: r,
      once: i
    }), this;
  }
  /**
   * Adds an event listener that only fires once for the given event string.
   *
   * @param {string} event
   * @param {Function} handler
   * @param ctx
   * @returns
   */
  once(t, n, r) {
    return this.on(t, n, r, !0);
  }
  /**
   * Removes an event listener for the given event string.
   *
   * @param {string} event
   * @param {Function} handler
   * @returns
   */
  off(t, n) {
    if (U(this.bindings) || U(this.bindings[t]))
      return this;
    if (U(n))
      delete this.bindings[t];
    else {
      var r;
      (r = this.bindings[t]) == null || r.forEach((i, o) => {
        if (i.handler === n) {
          var s;
          (s = this.bindings[t]) == null || s.splice(o, 1);
        }
      });
    }
    return this;
  }
  /**
   * Triggers an event listener for the given event string.
   *
   * @param {string} event
   * @returns
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  trigger(t, ...n) {
    if (!U(this.bindings) && this.bindings[t]) {
      var r;
      (r = this.bindings[t]) == null || r.forEach((i, o) => {
        const {
          ctx: s,
          handler: c,
          once: a
        } = i, u = s || this;
        if (c.apply(u, n), a) {
          var d;
          (d = this.bindings[t]) == null || d.splice(o, 1);
        }
      });
    }
    return this;
  }
}
function J() {
  return J = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, J.apply(null, arguments);
}
function Lt(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
const ye = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
ye.defaultMerge;
function Br(e, t) {
  return t;
}
function Vr(e, t) {
  return e.filter((n) => n !== void 0);
}
var gn;
(function(e) {
  e[e.NOT = 0] = "NOT", e[e.RECORD = 1] = "RECORD", e[e.ARRAY = 2] = "ARRAY", e[e.SET = 3] = "SET", e[e.MAP = 4] = "MAP", e[e.OTHER = 5] = "OTHER";
})(gn || (gn = {}));
function mn(e) {
  return typeof e != "object" || e === null ? 0 : Array.isArray(e) ? 2 : Yr(e) ? 1 : e instanceof Set ? 3 : e instanceof Map ? 4 : 5;
}
function Nr(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const r of [...Object.keys(n), ...Object.getOwnPropertySymbols(n)])
      t.add(r);
  return t;
}
function Wr(e, t) {
  return typeof e == "object" && Object.prototype.propertyIsEnumerable.call(e, t);
}
function Bn(e) {
  return {
    *[Symbol.iterator]() {
      for (const t of e)
        for (const n of t)
          yield n;
    }
  };
}
const vn = /* @__PURE__ */ new Set(["[object Object]", "[object Module]"]);
function Yr(e) {
  if (!vn.has(Object.prototype.toString.call(e)))
    return !1;
  const {
    constructor: t
  } = e;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(n === null || typeof n != "object" || !vn.has(Object.prototype.toString.call(n)) || !n.hasOwnProperty("isPrototypeOf"));
}
function Ur(e, t, n) {
  const r = {};
  for (const i of Nr(e)) {
    const o = [];
    for (const a of e)
      Wr(a, i) && o.push(a[i]);
    if (o.length === 0)
      continue;
    const s = t.metaDataUpdater(n, {
      key: i,
      parents: e
    }), c = Vn(o, t, s);
    c !== ye.skip && (i === "__proto__" ? Object.defineProperty(r, i, {
      value: c,
      configurable: !0,
      enumerable: !0,
      writable: !0
    }) : r[i] = c);
  }
  return r;
}
function qr(e) {
  return e.flat();
}
function zr(e) {
  return new Set(Bn(e));
}
function Jr(e) {
  return new Map(Bn(e));
}
function Kr(e) {
  return e.at(-1);
}
const st = {
  mergeRecords: Ur,
  mergeArrays: qr,
  mergeSets: zr,
  mergeMaps: Jr,
  mergeOthers: Kr
};
function Dt(...e) {
  return Xr({})(...e);
}
function Xr(e, t) {
  const n = Gr(e, r);
  function r(...i) {
    return Vn(i, n, t);
  }
  return r;
}
function Gr(e, t) {
  var n, r, i;
  return {
    defaultMergeFunctions: st,
    mergeFunctions: J({}, st, Object.fromEntries(Object.entries(e).filter(([o, s]) => Object.hasOwn(st, o)).map(([o, s]) => s === !1 ? [o, st.mergeOthers] : [o, s]))),
    metaDataUpdater: (n = e.metaDataUpdater) != null ? n : Br,
    deepmerge: t,
    useImplicitDefaultMerging: (r = e.enableImplicitDefaultMerging) != null ? r : !1,
    filterValues: e.filterValues === !1 ? void 0 : (i = e.filterValues) != null ? i : Vr,
    actions: ye
  };
}
function Vn(e, t, n) {
  var r;
  const i = (r = t.filterValues == null ? void 0 : t.filterValues(e, n)) != null ? r : e;
  if (i.length === 0)
    return;
  if (i.length === 1)
    return Rt(i, t, n);
  const o = mn(i[0]);
  if (o !== 0 && o !== 5) {
    for (let s = 1; s < i.length; s++)
      if (mn(i[s]) !== o)
        return Rt(i, t, n);
  }
  switch (o) {
    case 1:
      return Zr(i, t, n);
    case 2:
      return Qr(i, t, n);
    case 3:
      return ei(i, t, n);
    case 4:
      return ti(i, t, n);
    default:
      return Rt(i, t, n);
  }
}
function Zr(e, t, n) {
  const r = t.mergeFunctions.mergeRecords(e, t, n);
  return r === ye.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeRecords !== t.defaultMergeFunctions.mergeRecords ? t.defaultMergeFunctions.mergeRecords(e, t, n) : r;
}
function Qr(e, t, n) {
  const r = t.mergeFunctions.mergeArrays(e, t, n);
  return r === ye.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeArrays !== t.defaultMergeFunctions.mergeArrays ? t.defaultMergeFunctions.mergeArrays(e) : r;
}
function ei(e, t, n) {
  const r = t.mergeFunctions.mergeSets(e, t, n);
  return r === ye.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeSets !== t.defaultMergeFunctions.mergeSets ? t.defaultMergeFunctions.mergeSets(e) : r;
}
function ti(e, t, n) {
  const r = t.mergeFunctions.mergeMaps(e, t, n);
  return r === ye.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeMaps !== t.defaultMergeFunctions.mergeMaps ? t.defaultMergeFunctions.mergeMaps(e) : r;
}
function Rt(e, t, n) {
  const r = t.mergeFunctions.mergeOthers(e, t, n);
  return r === ye.defaultMerge || t.useImplicitDefaultMerging && r === void 0 && t.mergeFunctions.mergeOthers !== t.defaultMergeFunctions.mergeOthers ? t.defaultMergeFunctions.mergeOthers(e) : r;
}
function jt(e) {
  const t = Object.getOwnPropertyNames(e.constructor.prototype);
  for (let n = 0; n < t.length; n++) {
    const r = t[n], i = e[r];
    r !== "constructor" && typeof i == "function" && (e[r] = i.bind(e));
  }
  return e;
}
function ni(e, t) {
  return (n) => {
    if (e.isOpen()) {
      const r = e.el && n.currentTarget === e.el;
      (!U(t) && n.currentTarget.matches(t) || r) && e.tour.next();
    }
  };
}
function ri(e) {
  const {
    event: t,
    selector: n
  } = e.options.advanceOn || {};
  if (t) {
    const r = ni(e, n);
    let i = null;
    if (!U(n) && (i = document.querySelector(n), !i))
      return console.error(`No element was found for the selector supplied to advanceOn: ${n}`);
    i ? (i.addEventListener(t, r), e.on("destroy", () => i.removeEventListener(t, r))) : (document.body.addEventListener(t, r, !0), e.on("destroy", () => document.body.removeEventListener(t, r, !0)));
  } else
    return console.error("advanceOn was defined, but no event name was passed.");
}
class ii {
  constructor(t) {
  }
}
class oi {
  constructor(t, n) {
  }
}
function Nn(e) {
  return !Ke(e) || e === "" ? "" : e.charAt(e.length - 1) !== "-" ? `${e}-` : e;
}
function si(e) {
  const t = e.options.attachTo || {}, n = Object.assign({}, t);
  if (ve(n.element) && (n.element = n.element.call(e)), Ke(n.element)) {
    try {
      n.element = document.querySelector(n.element);
    } catch {
    }
    n.element || console.error(`The element for this Shepherd step was not found ${t.element}`);
  }
  return n;
}
function li(e) {
  return e.options.extraHighlights ? e.options.extraHighlights.flatMap((t) => Array.from(document.querySelectorAll(t))) : [];
}
function Wn(e) {
  return e == null ? !0 : !e.element || !e.on;
}
function Yn() {
  let e = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
    const n = (e + Math.random() * 16) % 16 | 0;
    return e = Math.floor(e / 16), (t == "x" ? n : n & 3 | 8).toString(16);
  });
}
const ci = ["top", "right", "bottom", "left"], bn = ["start", "end"], yn = /* @__PURE__ */ ci.reduce((e, t) => e.concat(t, t + "-" + bn[0], t + "-" + bn[1]), []), $e = Math.min, Oe = Math.max, at = Math.round, lt = Math.floor, le = (e) => ({
  x: e,
  y: e
}), ai = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, ui = {
  start: "end",
  end: "start"
};
function At(e, t, n) {
  return Oe(e, $e(t, n));
}
function Ce(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function he(e) {
  return e.split("-")[0];
}
function de(e) {
  return e.split("-")[1];
}
function Ht(e) {
  return e === "x" ? "y" : "x";
}
function $t(e) {
  return e === "y" ? "height" : "width";
}
function Be(e) {
  return ["top", "bottom"].includes(he(e)) ? "y" : "x";
}
function Bt(e) {
  return Ht(Be(e));
}
function Un(e, t, n) {
  n === void 0 && (n = !1);
  const r = de(e), i = Bt(e), o = $t(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = ft(s)), [s, ft(s)];
}
function fi(e) {
  const t = ft(e);
  return [ut(e), t, ut(t)];
}
function ut(e) {
  return e.replace(/start|end/g, (t) => ui[t]);
}
function di(e, t, n) {
  const r = ["left", "right"], i = ["right", "left"], o = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? o : s;
    default:
      return [];
  }
}
function hi(e, t, n, r) {
  const i = de(e);
  let o = di(he(e), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), t && (o = o.concat(o.map(ut)))), o;
}
function ft(e) {
  return e.replace(/left|right|bottom|top/g, (t) => ai[t]);
}
function pi(e) {
  return J({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, e);
}
function qn(e) {
  return typeof e != "number" ? pi(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function dt(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
const gi = ["crossAxis", "alignment", "allowedPlacements", "autoAlignment"], mi = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"], vi = ["mainAxis", "crossAxis", "limiter"];
function wn(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = Be(t), s = Bt(t), c = $t(s), a = he(t), u = o === "y", d = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, f = r[c] / 2 - i[c] / 2;
  let g;
  switch (a) {
    case "top":
      g = {
        x: d,
        y: r.y - i.height
      };
      break;
    case "bottom":
      g = {
        x: d,
        y: r.y + r.height
      };
      break;
    case "right":
      g = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      g = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      g = {
        x: r.x,
        y: r.y
      };
  }
  switch (de(t)) {
    case "start":
      g[s] -= f * (n && u ? -1 : 1);
      break;
    case "end":
      g[s] += f * (n && u ? -1 : 1);
      break;
  }
  return g;
}
const bi = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, c = o.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: d,
    y: h
  } = wn(u, r, a), f = r, g = {}, b = 0;
  for (let E = 0; E < c.length; E++) {
    const {
      name: S,
      fn: w
    } = c[E], {
      x: _,
      y: O,
      data: y,
      reset: m
    } = await w({
      x: d,
      y: h,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: g,
      rects: u,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    d = _ ?? d, h = O ?? h, g = J({}, g, {
      [S]: J({}, g[S], y)
    }), m && b <= 50 && (b++, typeof m == "object" && (m.placement && (f = m.placement), m.rects && (u = m.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : m.rects), {
      x: d,
      y: h
    } = wn(u, f, a)), E = -1);
  }
  return {
    x: d,
    y: h,
    placement: f,
    strategy: i,
    middlewareData: g
  };
};
async function Vt(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: c,
    strategy: a
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: g = 0
  } = Ce(t, e), b = qn(g), S = c[f ? h === "floating" ? "reference" : "floating" : h], w = dt(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(S))) == null || n ? S : S.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)),
    boundary: u,
    rootBoundary: d,
    strategy: a
  })), _ = h === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, O = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), y = await (o.isElement == null ? void 0 : o.isElement(O)) ? await (o.getScale == null ? void 0 : o.getScale(O)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, m = dt(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: _,
    offsetParent: O,
    strategy: a
  }) : _);
  return {
    top: (w.top - m.top + b.top) / y.y,
    bottom: (m.bottom - w.bottom + b.bottom) / y.y,
    left: (w.left - m.left + b.left) / y.x,
    right: (m.right - w.right + b.right) / y.x
  };
}
const yi = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: c,
      middlewareData: a
    } = t, {
      element: u,
      padding: d = 0
    } = Ce(e, t) || {};
    if (u == null)
      return {};
    const h = qn(d), f = {
      x: n,
      y: r
    }, g = Bt(i), b = $t(g), E = await s.getDimensions(u), S = g === "y", w = S ? "top" : "left", _ = S ? "bottom" : "right", O = S ? "clientHeight" : "clientWidth", y = o.reference[b] + o.reference[g] - f[g] - o.floating[b], m = f[g] - o.reference[g], R = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let D = R ? R[O] : 0;
    (!D || !await (s.isElement == null ? void 0 : s.isElement(R))) && (D = c.floating[O] || o.floating[b]);
    const K = y / 2 - m / 2, W = D / 2 - E[b] / 2 - 1, X = $e(h[w], W), $ = $e(h[_], W), A = X, F = D - E[b] - $, L = D / 2 - E[b] / 2 + K, V = At(A, L, F), N = !a.arrow && de(i) != null && L !== V && o.reference[b] / 2 - (L < A ? X : $) - E[b] / 2 < 0, ne = N ? L < A ? L - A : L - F : 0;
    return {
      [g]: f[g] + ne,
      data: J({
        [g]: V,
        centerOffset: L - V - ne
      }, N && {
        alignmentOffset: ne
      }),
      reset: N
    };
  }
});
function wi(e, t, n) {
  return (e ? [...n.filter((i) => de(i) === e), ...n.filter((i) => de(i) !== e)] : n.filter((i) => he(i) === i)).filter((i) => e ? de(i) === e || (t ? ut(i) !== i : !1) : !0);
}
const _i = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(n) {
      var r, i, o;
      const {
        rects: s,
        middlewareData: c,
        placement: a,
        platform: u,
        elements: d
      } = n, h = Ce(t, n), {
        crossAxis: f = !1,
        alignment: g,
        allowedPlacements: b = yn,
        autoAlignment: E = !0
      } = h, S = Lt(h, gi), w = g !== void 0 || b === yn ? wi(g || null, E, b) : b, _ = await Vt(n, S), O = ((r = c.autoPlacement) == null ? void 0 : r.index) || 0, y = w[O];
      if (y == null)
        return {};
      const m = Un(y, s, await (u.isRTL == null ? void 0 : u.isRTL(d.floating)));
      if (a !== y)
        return {
          reset: {
            placement: w[0]
          }
        };
      const R = [_[he(y)], _[m[0]], _[m[1]]], D = [...((i = c.autoPlacement) == null ? void 0 : i.overflows) || [], {
        placement: y,
        overflows: R
      }], K = w[O + 1];
      if (K)
        return {
          data: {
            index: O + 1,
            overflows: D
          },
          reset: {
            placement: K
          }
        };
      const W = D.map((A) => {
        const F = de(A.placement);
        return [A.placement, F && f ? (
          // Check along the mainAxis and main crossAxis side.
          A.overflows.slice(0, 2).reduce((L, V) => L + V, 0)
        ) : (
          // Check only the mainAxis.
          A.overflows[0]
        ), A.overflows];
      }).sort((A, F) => A[1] - F[1]), $ = ((o = W.filter((A) => A[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        de(A[0]) ? 2 : 3
      ).every((F) => F <= 0))[0]) == null ? void 0 : o[0]) || W[0][0];
      return $ !== a ? {
        data: {
          index: O + 1,
          overflows: D
        },
        reset: {
          placement: $
        }
      } : {};
    }
  };
}, Ei = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(n) {
      var r, i;
      const {
        placement: o,
        middlewareData: s,
        rects: c,
        initialPlacement: a,
        platform: u,
        elements: d
      } = n, h = Ce(t, n), {
        mainAxis: f = !0,
        crossAxis: g = !0,
        fallbackPlacements: b,
        fallbackStrategy: E = "bestFit",
        fallbackAxisSideDirection: S = "none",
        flipAlignment: w = !0
      } = h, _ = Lt(h, mi);
      if ((r = s.arrow) != null && r.alignmentOffset)
        return {};
      const O = he(o), y = Be(a), m = he(a) === a, R = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), D = b || (m || !w ? [ft(a)] : fi(a)), K = S !== "none";
      !b && K && D.push(...hi(a, w, S, R));
      const W = [a, ...D], X = await Vt(n, _), $ = [];
      let A = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (f && $.push(X[O]), g) {
        const N = Un(o, c, R);
        $.push(X[N[0]], X[N[1]]);
      }
      if (A = [...A, {
        placement: o,
        overflows: $
      }], !$.every((N) => N <= 0)) {
        var F, L;
        const N = (((F = s.flip) == null ? void 0 : F.index) || 0) + 1, ne = W[N];
        if (ne)
          return {
            data: {
              index: N,
              overflows: A
            },
            reset: {
              placement: ne
            }
          };
        let fe = (L = A.filter((Q) => Q.overflows[0] <= 0).sort((Q, Y) => Q.overflows[1] - Y.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!fe)
          switch (E) {
            case "bestFit": {
              var V;
              const Q = (V = A.filter((Y) => {
                if (K) {
                  const re = Be(Y.placement);
                  return re === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  re === "y";
                }
                return !0;
              }).map((Y) => [Y.placement, Y.overflows.filter((re) => re > 0).reduce((re, et) => re + et, 0)]).sort((Y, re) => Y[1] - re[1])[0]) == null ? void 0 : V[0];
              Q && (fe = Q);
              break;
            }
            case "initialPlacement":
              fe = a;
              break;
          }
        if (o !== fe)
          return {
            reset: {
              placement: fe
            }
          };
      }
      return {};
    }
  };
}, xi = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(n) {
      const {
        x: r,
        y: i,
        placement: o
      } = n, s = Ce(t, n), {
        mainAxis: c = !0,
        crossAxis: a = !1,
        limiter: u = {
          fn: (_) => {
            let {
              x: O,
              y
            } = _;
            return {
              x: O,
              y
            };
          }
        }
      } = s, d = Lt(s, vi), h = {
        x: r,
        y: i
      }, f = await Vt(n, d), g = Be(he(o)), b = Ht(g);
      let E = h[b], S = h[g];
      if (c) {
        const _ = b === "y" ? "top" : "left", O = b === "y" ? "bottom" : "right", y = E + f[_], m = E - f[O];
        E = At(y, E, m);
      }
      if (a) {
        const _ = g === "y" ? "top" : "left", O = g === "y" ? "bottom" : "right", y = S + f[_], m = S - f[O];
        S = At(y, S, m);
      }
      const w = u.fn(J({}, n, {
        [b]: E,
        [g]: S
      }));
      return J({}, w, {
        data: {
          x: w.x - r,
          y: w.y - i
        }
      });
    }
  };
}, Si = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(n) {
      const {
        x: r,
        y: i,
        placement: o,
        rects: s,
        middlewareData: c
      } = n, {
        offset: a = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = Ce(t, n), h = {
        x: r,
        y: i
      }, f = Be(o), g = Ht(f);
      let b = h[g], E = h[f];
      const S = Ce(a, n), w = typeof S == "number" ? {
        mainAxis: S,
        crossAxis: 0
      } : J({
        mainAxis: 0,
        crossAxis: 0
      }, S);
      if (u) {
        const y = g === "y" ? "height" : "width", m = s.reference[g] - s.floating[y] + w.mainAxis, R = s.reference[g] + s.reference[y] - w.mainAxis;
        b < m ? b = m : b > R && (b = R);
      }
      if (d) {
        var _, O;
        const y = g === "y" ? "width" : "height", m = ["top", "left"].includes(he(o)), R = s.reference[f] - s.floating[y] + (m && ((_ = c.offset) == null ? void 0 : _[f]) || 0) + (m ? 0 : w.crossAxis), D = s.reference[f] + s.reference[y] + (m ? 0 : ((O = c.offset) == null ? void 0 : O[f]) || 0) - (m ? w.crossAxis : 0);
        E < R ? E = R : E > D && (E = D);
      }
      return {
        [g]: b,
        [f]: E
      };
    }
  };
};
function pt() {
  return typeof window < "u";
}
function Ye(e) {
  return zn(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function G(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ue(e) {
  var t;
  return (t = (zn(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function zn(e) {
  return pt() ? e instanceof Node || e instanceof G(e).Node : !1;
}
function ie(e) {
  return pt() ? e instanceof Element || e instanceof G(e).Element : !1;
}
function ce(e) {
  return pt() ? e instanceof HTMLElement || e instanceof G(e).HTMLElement : !1;
}
function _n(e) {
  return !pt() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof G(e).ShadowRoot;
}
function Ze(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = oe(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function Oi(e) {
  return ["table", "td", "th"].includes(Ye(e));
}
function gt(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Nt(e) {
  const t = Wt(), n = ie(e) ? oe(e) : e;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function Ri(e) {
  let t = be(e);
  for (; ce(t) && !Ve(t); ) {
    if (Nt(t))
      return t;
    if (gt(t))
      return null;
    t = be(t);
  }
  return null;
}
function Wt() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ve(e) {
  return ["html", "body", "#document"].includes(Ye(e));
}
function oe(e) {
  return G(e).getComputedStyle(e);
}
function mt(e) {
  return ie(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function be(e) {
  if (Ye(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    _n(e) && e.host || // Fallback.
    ue(e)
  );
  return _n(t) ? t.host : t;
}
function Jn(e) {
  const t = be(e);
  return Ve(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ce(t) && Ze(t) ? t : Jn(t);
}
function Xe(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = Jn(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = G(i);
  if (o) {
    const c = Pt(s);
    return t.concat(s, s.visualViewport || [], Ze(i) ? i : [], c && n ? Xe(c) : []);
  }
  return t.concat(i, Xe(i, [], n));
}
function Pt(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Kn(e) {
  const t = oe(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = ce(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, c = at(n) !== o || at(r) !== s;
  return c && (n = o, r = s), {
    width: n,
    height: r,
    $: c
  };
}
function Yt(e) {
  return ie(e) ? e : e.contextElement;
}
function De(e) {
  const t = Yt(e);
  if (!ce(t))
    return le(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = Kn(t);
  let s = (o ? at(n.width) : n.width) / r, c = (o ? at(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const Ti = /* @__PURE__ */ le(0);
function Xn(e) {
  const t = G(e);
  return !Wt() || !t.visualViewport ? Ti : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Ci(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== G(e) ? !1 : t;
}
function Ae(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = Yt(e);
  let s = le(1);
  t && (r ? ie(r) && (s = De(r)) : s = De(e));
  const c = Ci(o, n, r) ? Xn(o) : le(0);
  let a = (i.left + c.x) / s.x, u = (i.top + c.y) / s.y, d = i.width / s.x, h = i.height / s.y;
  if (o) {
    const f = G(o), g = r && ie(r) ? G(r) : r;
    let b = f, E = Pt(b);
    for (; E && r && g !== b; ) {
      const S = De(E), w = E.getBoundingClientRect(), _ = oe(E), O = w.left + (E.clientLeft + parseFloat(_.paddingLeft)) * S.x, y = w.top + (E.clientTop + parseFloat(_.paddingTop)) * S.y;
      a *= S.x, u *= S.y, d *= S.x, h *= S.y, a += O, u += y, b = G(E), E = Pt(b);
    }
  }
  return dt({
    width: d,
    height: h,
    x: a,
    y: u
  });
}
function Ut(e, t) {
  const n = mt(e).scrollLeft;
  return t ? t.left + n : Ae(ue(e)).left + n;
}
function Gn(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Ut(e, r)
  )), o = r.top + t.scrollTop;
  return {
    x: i,
    y: o
  };
}
function Ai(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const o = i === "fixed", s = ue(r), c = t ? gt(t.floating) : !1;
  if (r === s || c && o)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = le(1);
  const d = le(0), h = ce(r);
  if ((h || !h && !o) && ((Ye(r) !== "body" || Ze(s)) && (a = mt(r)), ce(r))) {
    const g = Ae(r);
    u = De(r), d.x = g.x + r.clientLeft, d.y = g.y + r.clientTop;
  }
  const f = s && !h && !o ? Gn(s, a, !0) : le(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - a.scrollLeft * u.x + d.x + f.x,
    y: n.y * u.y - a.scrollTop * u.y + d.y + f.y
  };
}
function Pi(e) {
  return Array.from(e.getClientRects());
}
function ki(e) {
  const t = ue(e), n = mt(e), r = e.ownerDocument.body, i = Oe(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = Oe(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + Ut(e);
  const c = -n.scrollTop;
  return oe(r).direction === "rtl" && (s += Oe(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: c
  };
}
function Ii(e, t) {
  const n = G(e), r = ue(e), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, c = 0, a = 0;
  if (i) {
    o = i.width, s = i.height;
    const u = Wt();
    (!u || u && t === "fixed") && (c = i.offsetLeft, a = i.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: c,
    y: a
  };
}
function Mi(e, t) {
  const n = Ae(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = ce(e) ? De(e) : le(1), s = e.clientWidth * o.x, c = e.clientHeight * o.y, a = i * o.x, u = r * o.y;
  return {
    width: s,
    height: c,
    x: a,
    y: u
  };
}
function En(e, t, n) {
  let r;
  if (t === "viewport")
    r = Ii(e, n);
  else if (t === "document")
    r = ki(ue(e));
  else if (ie(t))
    r = Mi(t, n);
  else {
    const i = Xn(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return dt(r);
}
function Zn(e, t) {
  const n = be(e);
  return n === t || !ie(n) || Ve(n) ? !1 : oe(n).position === "fixed" || Zn(n, t);
}
function Fi(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Xe(e, [], !1).filter((c) => ie(c) && Ye(c) !== "body"), i = null;
  const o = oe(e).position === "fixed";
  let s = o ? be(e) : e;
  for (; ie(s) && !Ve(s); ) {
    const c = oe(s), a = Nt(s);
    !a && c.position === "fixed" && (i = null), (o ? !a && !i : !a && c.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Ze(s) && !a && Zn(e, s)) ? r = r.filter((d) => d !== s) : i = c, s = be(s);
  }
  return t.set(e, r), r;
}
function Li(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? gt(t) ? [] : Fi(t, this._c) : [].concat(n), r], c = s[0], a = s.reduce((u, d) => {
    const h = En(t, d, i);
    return u.top = Oe(h.top, u.top), u.right = $e(h.right, u.right), u.bottom = $e(h.bottom, u.bottom), u.left = Oe(h.left, u.left), u;
  }, En(t, c, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function Di(e) {
  const {
    width: t,
    height: n
  } = Kn(e);
  return {
    width: t,
    height: n
  };
}
function ji(e, t, n) {
  const r = ce(t), i = ue(t), o = n === "fixed", s = Ae(e, !0, o, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = le(0);
  if (r || !r && !o)
    if ((Ye(t) !== "body" || Ze(i)) && (c = mt(t)), r) {
      const f = Ae(t, !0, o, t);
      a.x = f.x + t.clientLeft, a.y = f.y + t.clientTop;
    } else i && (a.x = Ut(i));
  const u = i && !r && !o ? Gn(i, c) : le(0), d = s.left + c.scrollLeft - a.x - u.x, h = s.top + c.scrollTop - a.y - u.y;
  return {
    x: d,
    y: h,
    width: s.width,
    height: s.height
  };
}
function Tt(e) {
  return oe(e).position === "static";
}
function xn(e, t) {
  if (!ce(e) || oe(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return ue(e) === n && (n = n.ownerDocument.body), n;
}
function Qn(e, t) {
  const n = G(e);
  if (gt(e))
    return n;
  if (!ce(e)) {
    let i = be(e);
    for (; i && !Ve(i); ) {
      if (ie(i) && !Tt(i))
        return i;
      i = be(i);
    }
    return n;
  }
  let r = xn(e, t);
  for (; r && Oi(r) && Tt(r); )
    r = xn(r, t);
  return r && Ve(r) && Tt(r) && !Nt(r) ? n : r || Ri(e) || n;
}
const Hi = async function(t) {
  const n = this.getOffsetParent || Qn, r = this.getDimensions, i = await r(t.floating);
  return {
    reference: ji(t.reference, await n(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function $i(e) {
  return oe(e).direction === "rtl";
}
const Bi = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ai,
  getDocumentElement: ue,
  getClippingRect: Li,
  getOffsetParent: Qn,
  getElementRects: Hi,
  getClientRects: Pi,
  getDimensions: Di,
  getScale: De,
  isElement: ie,
  isRTL: $i
};
function Vi(e, t) {
  let n = null, r;
  const i = ue(e);
  function o() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), o();
    const {
      left: u,
      top: d,
      width: h,
      height: f
    } = e.getBoundingClientRect();
    if (c || t(), !h || !f)
      return;
    const g = lt(d), b = lt(i.clientWidth - (u + h)), E = lt(i.clientHeight - (d + f)), S = lt(u), _ = {
      rootMargin: -g + "px " + -b + "px " + -E + "px " + -S + "px",
      threshold: Oe(0, $e(1, a)) || 1
    };
    let O = !0;
    function y(m) {
      const R = m[0].intersectionRatio;
      if (R !== a) {
        if (!O)
          return s();
        R ? s(!1, R) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      O = !1;
    }
    try {
      n = new IntersectionObserver(y, J({}, _, {
        // Handle <iframe>s
        root: i.ownerDocument
      }));
    } catch {
      n = new IntersectionObserver(y, _);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function Ni(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, u = Yt(e), d = i || o ? [...u ? Xe(u) : [], ...Xe(t)] : [];
  d.forEach((w) => {
    i && w.addEventListener("scroll", n, {
      passive: !0
    }), o && w.addEventListener("resize", n);
  });
  const h = u && c ? Vi(u, n) : null;
  let f = -1, g = null;
  s && (g = new ResizeObserver((w) => {
    let [_] = w;
    _ && _.target === u && g && (g.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var O;
      (O = g) == null || O.observe(t);
    })), n();
  }), u && !a && g.observe(u), g.observe(t));
  let b, E = a ? Ae(e) : null;
  a && S();
  function S() {
    const w = Ae(e);
    E && (w.x !== E.x || w.y !== E.y || w.width !== E.width || w.height !== E.height) && n(), E = w, b = requestAnimationFrame(S);
  }
  return n(), () => {
    var w;
    d.forEach((_) => {
      i && _.removeEventListener("scroll", n), o && _.removeEventListener("resize", n);
    }), h == null || h(), (w = g) == null || w.disconnect(), g = null, a && cancelAnimationFrame(b);
  };
}
const Wi = _i, Yi = xi, Ui = Ei, qi = yi, zi = Si, Ji = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = J({
    platform: Bi
  }, n), o = J({}, i.platform, {
    _c: r
  });
  return bi(e, t, J({}, i, {
    platform: o
  }));
};
function Ki(e) {
  e.cleanup && e.cleanup();
  const t = e._getResolvedAttachToOptions();
  let n = t.element;
  const r = to(t, e), i = Wn(t);
  return i && (n = document.body, e.shepherdElementComponent.getElement().classList.add("shepherd-centered")), e.cleanup = Ni(n, e.el, () => {
    if (!e.el) {
      e.cleanup == null || e.cleanup();
      return;
    }
    Zi(n, e, r, i);
  }), e.target = t.element, r;
}
function Xi(e, t) {
  return {
    floatingUIOptions: Dt(e.floatingUIOptions || {}, t.floatingUIOptions || {})
  };
}
function Gi(e) {
  e.cleanup && e.cleanup(), e.cleanup = null;
}
function Zi(e, t, n, r) {
  return Ji(e, t.el, n).then(Qi(t, r)).then((i) => new Promise((o) => {
    setTimeout(() => o(i), 300);
  })).then((i) => {
    i != null && i.el && i.el.focus({
      preventScroll: !0
    });
  });
}
function Qi(e, t) {
  return ({
    x: n,
    y: r,
    placement: i,
    middlewareData: o
  }) => (e.el && (t ? Object.assign(e.el.style, {
    position: "fixed",
    left: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }) : Object.assign(e.el.style, {
    position: "absolute",
    left: `${n}px`,
    top: `${r}px`
  }), e.el.dataset.popperPlacement = i, eo(e.el, o)), e);
}
function eo(e, t) {
  const n = e.querySelector(".shepherd-arrow");
  if (He(n) && t.arrow) {
    const {
      x: r,
      y: i
    } = t.arrow;
    Object.assign(n.style, {
      left: r != null ? `${r}px` : "",
      top: i != null ? `${i}px` : ""
    });
  }
}
function to(e, t) {
  var n, r, i;
  const o = {
    strategy: "absolute"
  };
  o.middleware = [];
  const s = no(t), c = Wn(e), a = (n = e.on) == null ? void 0 : n.includes("auto"), u = (e == null || (r = e.on) == null ? void 0 : r.includes("-start")) || (e == null || (i = e.on) == null ? void 0 : i.includes("-end"));
  if (!c) {
    if (a) {
      var d;
      o.middleware.push(Wi({
        crossAxis: !0,
        alignment: u ? e == null || (d = e.on) == null ? void 0 : d.split("-").pop() : null
      }));
    } else
      o.middleware.push(Ui());
    if (o.middleware.push(
      // Replicate PopperJS default behavior.
      Yi({
        limiter: zi(),
        crossAxis: !0
      })
    ), s) {
      const h = typeof t.options.arrow == "object" ? t.options.arrow : {
        padding: 4
      };
      o.middleware.push(qi({
        element: s,
        padding: u ? h.padding : 0
      }));
    }
    a || (o.placement = e.on);
  }
  return Dt(o, t.options.floatingUIOptions || {});
}
function no(e) {
  return e.options.arrow && e.el ? e.el.querySelector(".shepherd-arrow") : !1;
}
function Z() {
}
function ro(e, t) {
  for (const n in t) e[n] = t[n];
  return (
    /** @type {T & S} */
    e
  );
}
function er(e) {
  return e();
}
function Sn() {
  return /* @__PURE__ */ Object.create(null);
}
function Qe(e) {
  e.forEach(er);
}
function qt(e) {
  return typeof e == "function";
}
function pe(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function io(e) {
  return Object.keys(e).length === 0;
}
function Ne(e, t) {
  e.appendChild(t);
}
function se(e, t, n) {
  e.insertBefore(t, n || null);
}
function te(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function oo(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function ae(e) {
  return document.createElement(e);
}
function On(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function tr(e) {
  return document.createTextNode(e);
}
function ht() {
  return tr(" ");
}
function so() {
  return tr("");
}
function vt(e, t, n, r) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r);
}
function M(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
const lo = ["width", "height"];
function Rn(e, t) {
  const n = Object.getOwnPropertyDescriptors(e.__proto__);
  for (const r in t)
    t[r] == null ? e.removeAttribute(r) : r === "style" ? e.style.cssText = t[r] : r === "__value" ? e.value = e[r] = t[r] : n[r] && n[r].set && lo.indexOf(r) === -1 ? e[r] = t[r] : M(e, r, t[r]);
}
function co(e) {
  return Array.from(e.childNodes);
}
function Me(e, t, n) {
  e.classList.toggle(t, !!n);
}
let Ge;
function Je(e) {
  Ge = e;
}
function nr() {
  if (!Ge) throw new Error("Function called outside component initialization");
  return Ge;
}
function ao(e) {
  nr().$$.on_mount.push(e);
}
function zt(e) {
  nr().$$.after_update.push(e);
}
const Le = [], We = [];
let je = [];
const Tn = [], uo = /* @__PURE__ */ Promise.resolve();
let kt = !1;
function fo() {
  kt || (kt = !0, uo.then(rr));
}
function It(e) {
  je.push(e);
}
const Ct = /* @__PURE__ */ new Set();
let Fe = 0;
function rr() {
  if (Fe !== 0)
    return;
  const e = Ge;
  do {
    try {
      for (; Fe < Le.length; ) {
        const t = Le[Fe];
        Fe++, Je(t), ho(t.$$);
      }
    } catch (t) {
      throw Le.length = 0, Fe = 0, t;
    }
    for (Je(null), Le.length = 0, Fe = 0; We.length; ) We.pop()();
    for (let t = 0; t < je.length; t += 1) {
      const n = je[t];
      Ct.has(n) || (Ct.add(n), n());
    }
    je.length = 0;
  } while (Le.length);
  for (; Tn.length; )
    Tn.pop()();
  kt = !1, Ct.clear(), Je(e);
}
function ho(e) {
  if (e.fragment !== null) {
    e.update(), Qe(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(It);
  }
}
function po(e) {
  const t = [], n = [];
  je.forEach((r) => e.indexOf(r) === -1 ? t.push(r) : n.push(r)), n.forEach((r) => r()), je = t;
}
const ct = /* @__PURE__ */ new Set();
let xe;
function Re() {
  xe = {
    r: 0,
    c: [],
    p: xe
    // parent group
  };
}
function Te() {
  xe.r || Qe(xe.c), xe = xe.p;
}
function k(e, t) {
  e && e.i && (ct.delete(e), e.i(t));
}
function H(e, t, n, r) {
  if (e && e.o) {
    if (ct.has(e)) return;
    ct.add(e), xe.c.push(() => {
      ct.delete(e), r && (n && e.d(1), r());
    }), e.o(t);
  } else r && r();
}
function Cn(e) {
  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);
}
function go(e, t) {
  const n = {}, r = {}, i = {
    $$scope: 1
  };
  let o = e.length;
  for (; o--; ) {
    const s = e[o], c = t[o];
    if (c) {
      for (const a in s)
        a in c || (r[a] = 1);
      for (const a in c)
        i[a] || (n[a] = c[a], i[a] = 1);
      e[o] = c;
    } else
      for (const a in s)
        i[a] = 1;
  }
  for (const s in r)
    s in n || (n[s] = void 0);
  return n;
}
function Pe(e) {
  e && e.c();
}
function we(e, t, n) {
  const {
    fragment: r,
    after_update: i
  } = e.$$;
  r && r.m(t, n), It(() => {
    const o = e.$$.on_mount.map(er).filter(qt);
    e.$$.on_destroy ? e.$$.on_destroy.push(...o) : Qe(o), e.$$.on_mount = [];
  }), i.forEach(It);
}
function _e(e, t) {
  const n = e.$$;
  n.fragment !== null && (po(n.after_update), Qe(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function mo(e, t) {
  e.$$.dirty[0] === -1 && (Le.push(e), fo(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function ge(e, t, n, r, i, o, s = null, c = [-1]) {
  const a = Ge;
  Je(e);
  const u = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: o,
    update: Z,
    not_equal: i,
    bound: Sn(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (a ? a.$$.context : [])),
    // everything else
    callbacks: Sn(),
    dirty: c,
    skip_bound: !1,
    root: t.target || a.$$.root
  };
  s && s(u.root);
  let d = !1;
  if (u.ctx = n ? n(e, t.props || {}, (h, f, ...g) => {
    const b = g.length ? g[0] : f;
    return u.ctx && i(u.ctx[h], u.ctx[h] = b) && (!u.skip_bound && u.bound[h] && u.bound[h](b), d && mo(e, h)), f;
  }) : [], u.update(), d = !0, Qe(u.before_update), u.fragment = r ? r(u.ctx) : !1, t.target) {
    if (t.hydrate) {
      const h = co(t.target);
      u.fragment && u.fragment.l(h), h.forEach(te);
    } else
      u.fragment && u.fragment.c();
    t.intro && k(e.$$.fragment), we(e, t.target, t.anchor), rr();
  }
  Je(a);
}
class me {
  constructor() {
    this.$$ = void 0, this.$$set = void 0;
  }
  /** @returns {void} */
  $destroy() {
    _e(this, 1), this.$destroy = Z;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, n) {
    if (!qt(n))
      return Z;
    const r = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return r.push(n), () => {
      const i = r.indexOf(n);
      i !== -1 && r.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !io(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
const vo = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = {
  v: /* @__PURE__ */ new Set()
})).v.add(vo);
function bo(e) {
  let t, n, r, i, o;
  return {
    c() {
      t = ae("button"), M(t, "aria-label", n = /*label*/
      e[3] ? (
        /*label*/
        e[3]
      ) : null), M(t, "class", r = `${/*classes*/
      e[1] || ""} shepherd-button ${/*secondary*/
      e[4] ? "shepherd-button-secondary" : ""}`), t.disabled = /*disabled*/
      e[2], M(t, "tabindex", "0"), M(t, "type", "button");
    },
    m(s, c) {
      se(s, t, c), t.innerHTML = /*text*/
      e[5], i || (o = vt(t, "click", function() {
        qt(
          /*action*/
          e[0]
        ) && e[0].apply(this, arguments);
      }), i = !0);
    },
    p(s, [c]) {
      e = s, c & /*text*/
      32 && (t.innerHTML = /*text*/
      e[5]), c & /*label*/
      8 && n !== (n = /*label*/
      e[3] ? (
        /*label*/
        e[3]
      ) : null) && M(t, "aria-label", n), c & /*classes, secondary*/
      18 && r !== (r = `${/*classes*/
      e[1] || ""} shepherd-button ${/*secondary*/
      e[4] ? "shepherd-button-secondary" : ""}`) && M(t, "class", r), c & /*disabled*/
      4 && (t.disabled = /*disabled*/
      e[2]);
    },
    i: Z,
    o: Z,
    d(s) {
      s && te(t), i = !1, o();
    }
  };
}
function yo(e, t, n) {
  let {
    config: r,
    step: i
  } = t, o, s, c, a, u, d;
  function h(f) {
    return ve(f) ? f = f.call(i) : f;
  }
  return e.$$set = (f) => {
    "config" in f && n(6, r = f.config), "step" in f && n(7, i = f.step);
  }, e.$$.update = () => {
    e.$$.dirty & /*config, step*/
    192 && (n(0, o = r.action ? r.action.bind(i.tour) : null), n(1, s = r.classes), n(2, c = r.disabled ? h(r.disabled) : !1), n(3, a = r.label ? h(r.label) : null), n(4, u = r.secondary), n(5, d = r.text ? h(r.text) : null));
  }, [o, s, c, a, u, d, r, i];
}
class wo extends me {
  constructor(t) {
    super(), ge(this, t, yo, bo, pe, {
      config: 6,
      step: 7
    });
  }
}
function An(e, t, n) {
  const r = e.slice();
  return r[2] = t[n], r;
}
function Pn(e) {
  let t, n, r = Cn(
    /*buttons*/
    e[1]
  ), i = [];
  for (let s = 0; s < r.length; s += 1)
    i[s] = kn(An(e, r, s));
  const o = (s) => H(i[s], 1, 1, () => {
    i[s] = null;
  });
  return {
    c() {
      for (let s = 0; s < i.length; s += 1)
        i[s].c();
      t = so();
    },
    m(s, c) {
      for (let a = 0; a < i.length; a += 1)
        i[a] && i[a].m(s, c);
      se(s, t, c), n = !0;
    },
    p(s, c) {
      if (c & /*buttons, step*/
      3) {
        r = Cn(
          /*buttons*/
          s[1]
        );
        let a;
        for (a = 0; a < r.length; a += 1) {
          const u = An(s, r, a);
          i[a] ? (i[a].p(u, c), k(i[a], 1)) : (i[a] = kn(u), i[a].c(), k(i[a], 1), i[a].m(t.parentNode, t));
        }
        for (Re(), a = r.length; a < i.length; a += 1)
          o(a);
        Te();
      }
    },
    i(s) {
      if (!n) {
        for (let c = 0; c < r.length; c += 1)
          k(i[c]);
        n = !0;
      }
    },
    o(s) {
      i = i.filter(Boolean);
      for (let c = 0; c < i.length; c += 1)
        H(i[c]);
      n = !1;
    },
    d(s) {
      s && te(t), oo(i, s);
    }
  };
}
function kn(e) {
  let t, n;
  return t = new wo({
    props: {
      config: (
        /*config*/
        e[2]
      ),
      step: (
        /*step*/
        e[0]
      )
    }
  }), {
    c() {
      Pe(t.$$.fragment);
    },
    m(r, i) {
      we(t, r, i), n = !0;
    },
    p(r, i) {
      const o = {};
      i & /*buttons*/
      2 && (o.config = /*config*/
      r[2]), i & /*step*/
      1 && (o.step = /*step*/
      r[0]), t.$set(o);
    },
    i(r) {
      n || (k(t.$$.fragment, r), n = !0);
    },
    o(r) {
      H(t.$$.fragment, r), n = !1;
    },
    d(r) {
      _e(t, r);
    }
  };
}
function _o(e) {
  let t, n, r = (
    /*buttons*/
    e[1] && Pn(e)
  );
  return {
    c() {
      t = ae("footer"), r && r.c(), M(t, "class", "shepherd-footer");
    },
    m(i, o) {
      se(i, t, o), r && r.m(t, null), n = !0;
    },
    p(i, [o]) {
      /*buttons*/
      i[1] ? r ? (r.p(i, o), o & /*buttons*/
      2 && k(r, 1)) : (r = Pn(i), r.c(), k(r, 1), r.m(t, null)) : r && (Re(), H(r, 1, 1, () => {
        r = null;
      }), Te());
    },
    i(i) {
      n || (k(r), n = !0);
    },
    o(i) {
      H(r), n = !1;
    },
    d(i) {
      i && te(t), r && r.d();
    }
  };
}
function Eo(e, t, n) {
  let r, {
    step: i
  } = t;
  return e.$$set = (o) => {
    "step" in o && n(0, i = o.step);
  }, e.$$.update = () => {
    e.$$.dirty & /*step*/
    1 && n(1, r = i.options.buttons);
  }, [i, r];
}
class xo extends me {
  constructor(t) {
    super(), ge(this, t, Eo, _o, pe, {
      step: 0
    });
  }
}
function So(e) {
  let t, n, r, i, o;
  return {
    c() {
      t = ae("button"), n = ae("span"), n.textContent = "×", M(n, "aria-hidden", "true"), M(t, "aria-label", r = /*cancelIcon*/
      e[0].label ? (
        /*cancelIcon*/
        e[0].label
      ) : "Close Tour"), M(t, "class", "shepherd-cancel-icon"), M(t, "type", "button");
    },
    m(s, c) {
      se(s, t, c), Ne(t, n), i || (o = vt(
        t,
        "click",
        /*handleCancelClick*/
        e[1]
      ), i = !0);
    },
    p(s, [c]) {
      c & /*cancelIcon*/
      1 && r !== (r = /*cancelIcon*/
      s[0].label ? (
        /*cancelIcon*/
        s[0].label
      ) : "Close Tour") && M(t, "aria-label", r);
    },
    i: Z,
    o: Z,
    d(s) {
      s && te(t), i = !1, o();
    }
  };
}
function Oo(e, t, n) {
  let {
    cancelIcon: r,
    step: i
  } = t;
  const o = (s) => {
    s.preventDefault(), i.cancel();
  };
  return e.$$set = (s) => {
    "cancelIcon" in s && n(0, r = s.cancelIcon), "step" in s && n(2, i = s.step);
  }, [r, o, i];
}
class Ro extends me {
  constructor(t) {
    super(), ge(this, t, Oo, So, pe, {
      cancelIcon: 0,
      step: 2
    });
  }
}
function To(e) {
  let t;
  return {
    c() {
      t = ae("h3"), M(
        t,
        "id",
        /*labelId*/
        e[1]
      ), M(t, "class", "shepherd-title");
    },
    m(n, r) {
      se(n, t, r), e[3](t);
    },
    p(n, [r]) {
      r & /*labelId*/
      2 && M(
        t,
        "id",
        /*labelId*/
        n[1]
      );
    },
    i: Z,
    o: Z,
    d(n) {
      n && te(t), e[3](null);
    }
  };
}
function Co(e, t, n) {
  let {
    labelId: r,
    element: i,
    title: o
  } = t;
  zt(() => {
    ve(o) && n(2, o = o()), n(0, i.innerHTML = o, i);
  });
  function s(c) {
    We[c ? "unshift" : "push"](() => {
      i = c, n(0, i);
    });
  }
  return e.$$set = (c) => {
    "labelId" in c && n(1, r = c.labelId), "element" in c && n(0, i = c.element), "title" in c && n(2, o = c.title);
  }, [i, r, o, s];
}
class Ao extends me {
  constructor(t) {
    super(), ge(this, t, Co, To, pe, {
      labelId: 1,
      element: 0,
      title: 2
    });
  }
}
function In(e) {
  let t, n;
  return t = new Ao({
    props: {
      labelId: (
        /*labelId*/
        e[0]
      ),
      title: (
        /*title*/
        e[2]
      )
    }
  }), {
    c() {
      Pe(t.$$.fragment);
    },
    m(r, i) {
      we(t, r, i), n = !0;
    },
    p(r, i) {
      const o = {};
      i & /*labelId*/
      1 && (o.labelId = /*labelId*/
      r[0]), i & /*title*/
      4 && (o.title = /*title*/
      r[2]), t.$set(o);
    },
    i(r) {
      n || (k(t.$$.fragment, r), n = !0);
    },
    o(r) {
      H(t.$$.fragment, r), n = !1;
    },
    d(r) {
      _e(t, r);
    }
  };
}
function Mn(e) {
  let t, n;
  return t = new Ro({
    props: {
      cancelIcon: (
        /*cancelIcon*/
        e[3]
      ),
      step: (
        /*step*/
        e[1]
      )
    }
  }), {
    c() {
      Pe(t.$$.fragment);
    },
    m(r, i) {
      we(t, r, i), n = !0;
    },
    p(r, i) {
      const o = {};
      i & /*cancelIcon*/
      8 && (o.cancelIcon = /*cancelIcon*/
      r[3]), i & /*step*/
      2 && (o.step = /*step*/
      r[1]), t.$set(o);
    },
    i(r) {
      n || (k(t.$$.fragment, r), n = !0);
    },
    o(r) {
      H(t.$$.fragment, r), n = !1;
    },
    d(r) {
      _e(t, r);
    }
  };
}
function Po(e) {
  let t, n, r, i = (
    /*title*/
    e[2] && In(e)
  ), o = (
    /*cancelIcon*/
    e[3] && /*cancelIcon*/
    e[3].enabled && Mn(e)
  );
  return {
    c() {
      t = ae("header"), i && i.c(), n = ht(), o && o.c(), M(t, "class", "shepherd-header");
    },
    m(s, c) {
      se(s, t, c), i && i.m(t, null), Ne(t, n), o && o.m(t, null), r = !0;
    },
    p(s, [c]) {
      /*title*/
      s[2] ? i ? (i.p(s, c), c & /*title*/
      4 && k(i, 1)) : (i = In(s), i.c(), k(i, 1), i.m(t, n)) : i && (Re(), H(i, 1, 1, () => {
        i = null;
      }), Te()), /*cancelIcon*/
      s[3] && /*cancelIcon*/
      s[3].enabled ? o ? (o.p(s, c), c & /*cancelIcon*/
      8 && k(o, 1)) : (o = Mn(s), o.c(), k(o, 1), o.m(t, null)) : o && (Re(), H(o, 1, 1, () => {
        o = null;
      }), Te());
    },
    i(s) {
      r || (k(i), k(o), r = !0);
    },
    o(s) {
      H(i), H(o), r = !1;
    },
    d(s) {
      s && te(t), i && i.d(), o && o.d();
    }
  };
}
function ko(e, t, n) {
  let {
    labelId: r,
    step: i
  } = t, o, s;
  return e.$$set = (c) => {
    "labelId" in c && n(0, r = c.labelId), "step" in c && n(1, i = c.step);
  }, e.$$.update = () => {
    e.$$.dirty & /*step*/
    2 && (n(2, o = i.options.title), n(3, s = i.options.cancelIcon));
  }, [r, i, o, s];
}
class Io extends me {
  constructor(t) {
    super(), ge(this, t, ko, Po, pe, {
      labelId: 0,
      step: 1
    });
  }
}
function Mo(e) {
  let t;
  return {
    c() {
      t = ae("div"), M(t, "class", "shepherd-text"), M(
        t,
        "id",
        /*descriptionId*/
        e[1]
      );
    },
    m(n, r) {
      se(n, t, r), e[3](t);
    },
    p(n, [r]) {
      r & /*descriptionId*/
      2 && M(
        t,
        "id",
        /*descriptionId*/
        n[1]
      );
    },
    i: Z,
    o: Z,
    d(n) {
      n && te(t), e[3](null);
    }
  };
}
function Fo(e, t, n) {
  let {
    descriptionId: r,
    element: i,
    step: o
  } = t;
  zt(() => {
    let {
      text: c
    } = o.options;
    ve(c) && (c = c.call(o)), He(c) ? i.appendChild(c) : n(0, i.innerHTML = c, i);
  });
  function s(c) {
    We[c ? "unshift" : "push"](() => {
      i = c, n(0, i);
    });
  }
  return e.$$set = (c) => {
    "descriptionId" in c && n(1, r = c.descriptionId), "element" in c && n(0, i = c.element), "step" in c && n(2, o = c.step);
  }, [i, r, o, s];
}
class Lo extends me {
  constructor(t) {
    super(), ge(this, t, Fo, Mo, pe, {
      descriptionId: 1,
      element: 0,
      step: 2
    });
  }
}
function Fn(e) {
  let t, n;
  return t = new Io({
    props: {
      labelId: (
        /*labelId*/
        e[1]
      ),
      step: (
        /*step*/
        e[2]
      )
    }
  }), {
    c() {
      Pe(t.$$.fragment);
    },
    m(r, i) {
      we(t, r, i), n = !0;
    },
    p(r, i) {
      const o = {};
      i & /*labelId*/
      2 && (o.labelId = /*labelId*/
      r[1]), i & /*step*/
      4 && (o.step = /*step*/
      r[2]), t.$set(o);
    },
    i(r) {
      n || (k(t.$$.fragment, r), n = !0);
    },
    o(r) {
      H(t.$$.fragment, r), n = !1;
    },
    d(r) {
      _e(t, r);
    }
  };
}
function Ln(e) {
  let t, n;
  return t = new Lo({
    props: {
      descriptionId: (
        /*descriptionId*/
        e[0]
      ),
      step: (
        /*step*/
        e[2]
      )
    }
  }), {
    c() {
      Pe(t.$$.fragment);
    },
    m(r, i) {
      we(t, r, i), n = !0;
    },
    p(r, i) {
      const o = {};
      i & /*descriptionId*/
      1 && (o.descriptionId = /*descriptionId*/
      r[0]), i & /*step*/
      4 && (o.step = /*step*/
      r[2]), t.$set(o);
    },
    i(r) {
      n || (k(t.$$.fragment, r), n = !0);
    },
    o(r) {
      H(t.$$.fragment, r), n = !1;
    },
    d(r) {
      _e(t, r);
    }
  };
}
function Dn(e) {
  let t, n;
  return t = new xo({
    props: {
      step: (
        /*step*/
        e[2]
      )
    }
  }), {
    c() {
      Pe(t.$$.fragment);
    },
    m(r, i) {
      we(t, r, i), n = !0;
    },
    p(r, i) {
      const o = {};
      i & /*step*/
      4 && (o.step = /*step*/
      r[2]), t.$set(o);
    },
    i(r) {
      n || (k(t.$$.fragment, r), n = !0);
    },
    o(r) {
      H(t.$$.fragment, r), n = !1;
    },
    d(r) {
      _e(t, r);
    }
  };
}
function Do(e) {
  let t, n = !U(
    /*step*/
    e[2].options.title
  ) || /*step*/
  e[2].options.cancelIcon && /*step*/
  e[2].options.cancelIcon.enabled, r, i = !U(
    /*step*/
    e[2].options.text
  ), o, s = Array.isArray(
    /*step*/
    e[2].options.buttons
  ) && /*step*/
  e[2].options.buttons.length, c, a = n && Fn(e), u = i && Ln(e), d = s && Dn(e);
  return {
    c() {
      t = ae("div"), a && a.c(), r = ht(), u && u.c(), o = ht(), d && d.c(), M(t, "class", "shepherd-content");
    },
    m(h, f) {
      se(h, t, f), a && a.m(t, null), Ne(t, r), u && u.m(t, null), Ne(t, o), d && d.m(t, null), c = !0;
    },
    p(h, [f]) {
      f & /*step*/
      4 && (n = !U(
        /*step*/
        h[2].options.title
      ) || /*step*/
      h[2].options.cancelIcon && /*step*/
      h[2].options.cancelIcon.enabled), n ? a ? (a.p(h, f), f & /*step*/
      4 && k(a, 1)) : (a = Fn(h), a.c(), k(a, 1), a.m(t, r)) : a && (Re(), H(a, 1, 1, () => {
        a = null;
      }), Te()), f & /*step*/
      4 && (i = !U(
        /*step*/
        h[2].options.text
      )), i ? u ? (u.p(h, f), f & /*step*/
      4 && k(u, 1)) : (u = Ln(h), u.c(), k(u, 1), u.m(t, o)) : u && (Re(), H(u, 1, 1, () => {
        u = null;
      }), Te()), f & /*step*/
      4 && (s = Array.isArray(
        /*step*/
        h[2].options.buttons
      ) && /*step*/
      h[2].options.buttons.length), s ? d ? (d.p(h, f), f & /*step*/
      4 && k(d, 1)) : (d = Dn(h), d.c(), k(d, 1), d.m(t, null)) : d && (Re(), H(d, 1, 1, () => {
        d = null;
      }), Te());
    },
    i(h) {
      c || (k(a), k(u), k(d), c = !0);
    },
    o(h) {
      H(a), H(u), H(d), c = !1;
    },
    d(h) {
      h && te(t), a && a.d(), u && u.d(), d && d.d();
    }
  };
}
function jo(e, t, n) {
  let {
    descriptionId: r,
    labelId: i,
    step: o
  } = t;
  return e.$$set = (s) => {
    "descriptionId" in s && n(0, r = s.descriptionId), "labelId" in s && n(1, i = s.labelId), "step" in s && n(2, o = s.step);
  }, [r, i, o];
}
class Ho extends me {
  constructor(t) {
    super(), ge(this, t, jo, Do, pe, {
      descriptionId: 0,
      labelId: 1,
      step: 2
    });
  }
}
function jn(e) {
  let t;
  return {
    c() {
      t = ae("div"), M(t, "class", "shepherd-arrow"), M(t, "data-popper-arrow", "");
    },
    m(n, r) {
      se(n, t, r);
    },
    d(n) {
      n && te(t);
    }
  };
}
function $o(e) {
  let t, n, r, i, o, s, c, a, u = (
    /*step*/
    e[4].options.arrow && /*step*/
    e[4].options.attachTo && /*step*/
    e[4].options.attachTo.element && /*step*/
    e[4].options.attachTo.on && jn()
  );
  r = new Ho({
    props: {
      descriptionId: (
        /*descriptionId*/
        e[2]
      ),
      labelId: (
        /*labelId*/
        e[3]
      ),
      step: (
        /*step*/
        e[4]
      )
    }
  });
  let d = [
    {
      "aria-describedby": i = U(
        /*step*/
        e[4].options.text
      ) ? null : (
        /*descriptionId*/
        e[2]
      )
    },
    {
      "aria-labelledby": o = /*step*/
      e[4].options.title ? (
        /*labelId*/
        e[3]
      ) : null
    },
    /*dataStepId*/
    e[1],
    {
      open: "true"
    }
  ], h = {};
  for (let f = 0; f < d.length; f += 1)
    h = ro(h, d[f]);
  return {
    c() {
      t = ae("dialog"), u && u.c(), n = ht(), Pe(r.$$.fragment), Rn(t, h), Me(
        t,
        "shepherd-has-cancel-icon",
        /*hasCancelIcon*/
        e[5]
      ), Me(
        t,
        "shepherd-has-title",
        /*hasTitle*/
        e[6]
      ), Me(t, "shepherd-element", !0);
    },
    m(f, g) {
      se(f, t, g), u && u.m(t, null), Ne(t, n), we(r, t, null), e[13](t), s = !0, c || (a = vt(
        t,
        "keydown",
        /*handleKeyDown*/
        e[7]
      ), c = !0);
    },
    p(f, [g]) {
      /*step*/
      f[4].options.arrow && /*step*/
      f[4].options.attachTo && /*step*/
      f[4].options.attachTo.element && /*step*/
      f[4].options.attachTo.on ? u || (u = jn(), u.c(), u.m(t, n)) : u && (u.d(1), u = null);
      const b = {};
      g & /*descriptionId*/
      4 && (b.descriptionId = /*descriptionId*/
      f[2]), g & /*labelId*/
      8 && (b.labelId = /*labelId*/
      f[3]), g & /*step*/
      16 && (b.step = /*step*/
      f[4]), r.$set(b), Rn(t, h = go(d, [(!s || g & /*step, descriptionId*/
      20 && i !== (i = U(
        /*step*/
        f[4].options.text
      ) ? null : (
        /*descriptionId*/
        f[2]
      ))) && {
        "aria-describedby": i
      }, (!s || g & /*step, labelId*/
      24 && o !== (o = /*step*/
      f[4].options.title ? (
        /*labelId*/
        f[3]
      ) : null)) && {
        "aria-labelledby": o
      }, g & /*dataStepId*/
      2 && /*dataStepId*/
      f[1], {
        open: "true"
      }])), Me(
        t,
        "shepherd-has-cancel-icon",
        /*hasCancelIcon*/
        f[5]
      ), Me(
        t,
        "shepherd-has-title",
        /*hasTitle*/
        f[6]
      ), Me(t, "shepherd-element", !0);
    },
    i(f) {
      s || (k(r.$$.fragment, f), s = !0);
    },
    o(f) {
      H(r.$$.fragment, f), s = !1;
    },
    d(f) {
      f && te(t), u && u.d(), _e(r), e[13](null), c = !1, a();
    }
  };
}
const Bo = 9, Vo = 27, No = 37, Wo = 39;
function Hn(e) {
  return e.split(" ").filter((t) => !!t.length);
}
function Yo(e, t, n) {
  let {
    classPrefix: r,
    element: i,
    descriptionId: o,
    firstFocusableElement: s,
    focusableElements: c,
    labelId: a,
    lastFocusableElement: u,
    step: d,
    dataStepId: h
  } = t, f, g, b;
  const E = () => i;
  ao(() => {
    n(1, h = {
      [`data-${r}shepherd-step-id`]: d.id
    }), n(9, c = i.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]')), n(8, s = c[0]), n(10, u = c[c.length - 1]);
  }), zt(() => {
    b !== d.options.classes && S();
  });
  function S() {
    w(b), b = d.options.classes, _(b);
  }
  function w(m) {
    if (Ke(m)) {
      const R = Hn(m);
      R.length && i.classList.remove(...R);
    }
  }
  function _(m) {
    if (Ke(m)) {
      const R = Hn(m);
      R.length && i.classList.add(...R);
    }
  }
  const O = (m) => {
    const {
      tour: R
    } = d;
    switch (m.keyCode) {
      case Bo:
        if (c.length === 0) {
          m.preventDefault();
          break;
        }
        m.shiftKey ? (document.activeElement === s || document.activeElement.classList.contains("shepherd-element")) && (m.preventDefault(), u.focus()) : document.activeElement === u && (m.preventDefault(), s.focus());
        break;
      case Vo:
        R.options.exitOnEsc && (m.preventDefault(), m.stopPropagation(), d.cancel());
        break;
      case No:
        R.options.keyboardNavigation && (m.preventDefault(), m.stopPropagation(), R.back());
        break;
      case Wo:
        R.options.keyboardNavigation && (m.preventDefault(), m.stopPropagation(), R.next());
        break;
    }
  };
  function y(m) {
    We[m ? "unshift" : "push"](() => {
      i = m, n(0, i);
    });
  }
  return e.$$set = (m) => {
    "classPrefix" in m && n(11, r = m.classPrefix), "element" in m && n(0, i = m.element), "descriptionId" in m && n(2, o = m.descriptionId), "firstFocusableElement" in m && n(8, s = m.firstFocusableElement), "focusableElements" in m && n(9, c = m.focusableElements), "labelId" in m && n(3, a = m.labelId), "lastFocusableElement" in m && n(10, u = m.lastFocusableElement), "step" in m && n(4, d = m.step), "dataStepId" in m && n(1, h = m.dataStepId);
  }, e.$$.update = () => {
    e.$$.dirty & /*step*/
    16 && (n(5, f = d.options && d.options.cancelIcon && d.options.cancelIcon.enabled), n(6, g = d.options && d.options.title));
  }, [i, h, o, a, d, f, g, O, s, c, u, r, E, y];
}
class Uo extends me {
  constructor(t) {
    super(), ge(this, t, Yo, $o, pe, {
      classPrefix: 11,
      element: 0,
      descriptionId: 2,
      firstFocusableElement: 8,
      focusableElements: 9,
      labelId: 3,
      lastFocusableElement: 10,
      step: 4,
      dataStepId: 1,
      getElement: 12
    });
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
class Mt extends Ft {
  constructor(t, n = {}) {
    return super(), this._resolvedAttachTo = void 0, this._resolvedExtraHighlightElements = void 0, this.classPrefix = void 0, this.el = void 0, this.target = void 0, this.tour = void 0, this.tour = t, this.classPrefix = this.tour.options ? Nn(this.tour.options.classPrefix) : "", this.styles = t.styles, this._resolvedAttachTo = null, jt(this), this._setOptions(n), this;
  }
  /**
   * Cancel the tour
   * Triggers the `cancel` event
   */
  cancel() {
    this.tour.cancel(), this.trigger("cancel");
  }
  /**
   * Complete the tour
   * Triggers the `complete` event
   */
  complete() {
    this.tour.complete(), this.trigger("complete");
  }
  /**
   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.
   * Triggers `destroy` event
   */
  destroy() {
    Gi(this), He(this.el) && (this.el.remove(), this.el = null), this._updateStepTargetOnHide(), this.trigger("destroy");
  }
  /**
   * Returns the tour for the step
   * @return The tour instance
   */
  getTour() {
    return this.tour;
  }
  /**
   * Hide the step
   */
  hide() {
    var t;
    (t = this.tour.modal) == null || t.hide(), this.trigger("before-hide"), this.el && (this.el.hidden = !0), this._updateStepTargetOnHide(), this.trigger("hide");
  }
  /**
   * Resolves attachTo options.
   * @returns {{}|{element, on}}
   */
  _resolveExtraHiglightElements() {
    return this._resolvedExtraHighlightElements = li(this), this._resolvedExtraHighlightElements;
  }
  /**
   * Resolves attachTo options.
   * @returns {{}|{element, on}}
   */
  _resolveAttachToOptions() {
    return this._resolvedAttachTo = si(this), this._resolvedAttachTo;
  }
  /**
   * A selector for resolved attachTo options.
   * @returns {{}|{element, on}}
   * @private
   */
  _getResolvedAttachToOptions() {
    return this._resolvedAttachTo === null ? this._resolveAttachToOptions() : this._resolvedAttachTo;
  }
  /**
   * Check if the step is open and visible
   * @return True if the step is open and visible
   */
  isOpen() {
    return !!(this.el && !this.el.hidden);
  }
  /**
   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show
   */
  show() {
    return ve(this.options.beforeShowPromise) ? Promise.resolve(this.options.beforeShowPromise()).then(() => this._show()) : Promise.resolve(this._show());
  }
  /**
   * Updates the options of the step.
   *
   * @param {StepOptions} options The options for the step
   */
  updateStepOptions(t) {
    Object.assign(this.options, t), this.shepherdElementComponent && this.shepherdElementComponent.$set({
      step: this
    });
  }
  /**
   * Returns the element for the step
   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed
   */
  getElement() {
    return this.el;
  }
  /**
   * Returns the target for the step
   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found
   */
  getTarget() {
    return this.target;
  }
  /**
   * Creates Shepherd element for step based on options
   *
   * @return {HTMLElement} The DOM element for the step tooltip
   * @private
   */
  _createTooltipContent() {
    const t = `${this.id}-description`, n = `${this.id}-label`;
    return this.shepherdElementComponent = new Uo({
      target: this.tour.options.stepsContainer || document.body,
      props: {
        classPrefix: this.classPrefix,
        descriptionId: t,
        labelId: n,
        step: this,
        // @ts-expect-error TODO: investigate where styles comes from
        styles: this.styles
      }
    }), this.shepherdElementComponent.getElement();
  }
  /**
   * If a custom scrollToHandler is defined, call that, otherwise do the generic
   * scrollIntoView call.
   *
   * @param {boolean | ScrollIntoViewOptions} scrollToOptions - If true, uses the default `scrollIntoView`,
   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`
   * @private
   */
  _scrollTo(t) {
    const {
      element: n
    } = this._getResolvedAttachToOptions();
    ve(this.options.scrollToHandler) ? this.options.scrollToHandler(n) : $r(n) && typeof n.scrollIntoView == "function" && n.scrollIntoView(t);
  }
  /**
   * _getClassOptions gets all possible classes for the step
   * @param {StepOptions} stepOptions The step specific options
   * @returns {string} unique string from array of classes
   */
  _getClassOptions(t) {
    const n = this.tour && this.tour.options && this.tour.options.defaultStepOptions, r = t.classes ? t.classes : "", i = n && n.classes ? n.classes : "", o = [...r.split(" "), ...i.split(" ")], s = new Set(o);
    return Array.from(s).join(" ").trim();
  }
  /**
   * Sets the options for the step, maps `when` to events, sets up buttons
   * @param options - The options for the step
   */
  _setOptions(t = {}) {
    let n = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
    n = Dt({}, n || {}), this.options = Object.assign({
      arrow: !0
    }, n, t, Xi(n, t));
    const {
      when: r
    } = this.options;
    this.options.classes = this._getClassOptions(t), this.destroy(), this.id = this.options.id || `step-${Yn()}`, r && Object.keys(r).forEach((i) => {
      this.on(i, r[i], this);
    });
  }
  /**
   * Create the element and set up the FloatingUI instance
   * @private
   */
  _setupElements() {
    U(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && ri(this), Ki(this);
  }
  /**
   * Triggers `before-show`, generates the tooltip DOM content,
   * sets up a FloatingUI instance for the tooltip, then triggers `show`.
   * @private
   */
  _show() {
    var t;
    this.trigger("before-show"), this._resolveAttachToOptions(), this._resolveExtraHiglightElements(), this._setupElements(), this.tour.modal || this.tour.setupModal(), (t = this.tour.modal) == null || t.setupForStep(this), this._styleTargetElementForStep(this), this.el && (this.el.hidden = !1), this.options.scrollTo && setTimeout(() => {
      this._scrollTo(this.options.scrollTo);
    }), this.el && (this.el.hidden = !1);
    const n = this.shepherdElementComponent.getElement(), r = this.target || document.body, i = this._resolvedExtraHighlightElements;
    r.classList.add(`${this.classPrefix}shepherd-enabled`), r.classList.add(`${this.classPrefix}shepherd-target`), n.classList.add("shepherd-enabled"), i == null || i.forEach((o) => {
      o.classList.add(`${this.classPrefix}shepherd-enabled`), o.classList.add(`${this.classPrefix}shepherd-target`);
    }), this.trigger("show");
  }
  /**
   * Modulates the styles of the passed step's target element, based on the step's options and
   * the tour's `modal` option, to visually emphasize the element
   *
   * @param {Step} step The step object that attaches to the element
   * @private
   */
  _styleTargetElementForStep(t) {
    const n = t.target, r = t._resolvedExtraHighlightElements;
    if (!n)
      return;
    const i = t.options.highlightClass;
    i && (n.classList.add(i), r == null || r.forEach((o) => o.classList.add(i))), n.classList.remove("shepherd-target-click-disabled"), r == null || r.forEach((o) => o.classList.remove("shepherd-target-click-disabled")), t.options.canClickTarget === !1 && (n.classList.add("shepherd-target-click-disabled"), r == null || r.forEach((o) => o.classList.add("shepherd-target-click-disabled")));
  }
  /**
   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'
   * and 'shepherd-target' classes
   * @private
   */
  _updateStepTargetOnHide() {
    const t = this.target || document.body, n = this._resolvedExtraHighlightElements, r = this.options.highlightClass;
    r && (t.classList.remove(r), n == null || n.forEach((i) => i.classList.remove(r))), t.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`), n == null || n.forEach((i) => {
      i.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
    });
  }
}
function qo(e) {
  if (e) {
    const {
      steps: t
    } = e;
    t.forEach((n) => {
      n.options && n.options.canClickTarget === !1 && n.options.attachTo && (He(n.target) && n.target.classList.remove("shepherd-target-click-disabled"), n._resolvedExtraHighlightElements && n._resolvedExtraHighlightElements.forEach((r) => {
        He(r) && r.classList.remove("shepherd-target-click-disabled");
      }));
    });
  }
}
function zo(e) {
  let t = "";
  const {
    innerWidth: n,
    innerHeight: r
  } = window;
  return e.forEach((i) => {
    const {
      width: o,
      height: s,
      x: c = 0,
      y: a = 0,
      r: u = 0
    } = i, {
      topLeft: d = 0,
      topRight: h = 0,
      bottomRight: f = 0,
      bottomLeft: g = 0
    } = typeof u == "number" ? {
      topLeft: u,
      topRight: u,
      bottomRight: u,
      bottomLeft: u
    } : u;
    t += `M${c + d},${a}      a${d},${d},0,0,0-${d},${d}      V${s + a - g}      a${g},${g},0,0,0,${g},${g}      H${o + c - f}      a${f},${f},0,0,0,${f}-${f}      V${a + h}      a${h},${h},0,0,0-${h}-${h}      Z`;
  }), `M${n},${r}          H0          V0          H${n}          V${r}          Z          ${t}`.replace(/\s/g, "");
}
function Jo(e) {
  let t, n, r, i, o;
  return {
    c() {
      t = On("svg"), n = On("path"), M(
        n,
        "d",
        /*pathDefinition*/
        e[2]
      ), M(t, "class", r = `${/*modalIsVisible*/
      e[1] ? "shepherd-modal-is-visible" : ""} shepherd-modal-overlay-container`);
    },
    m(s, c) {
      se(s, t, c), Ne(t, n), e[11](t), i || (o = vt(
        t,
        "touchmove",
        /*_preventModalOverlayTouch*/
        e[3]
      ), i = !0);
    },
    p(s, [c]) {
      c & /*pathDefinition*/
      4 && M(
        n,
        "d",
        /*pathDefinition*/
        s[2]
      ), c & /*modalIsVisible*/
      2 && r !== (r = `${/*modalIsVisible*/
      s[1] ? "shepherd-modal-is-visible" : ""} shepherd-modal-overlay-container`) && M(t, "class", r);
    },
    i: Z,
    o: Z,
    d(s) {
      s && te(t), e[11](null), i = !1, o();
    }
  };
}
function ir(e) {
  if (!e)
    return null;
  const n = e instanceof HTMLElement && window.getComputedStyle(e).overflowY;
  return n !== "hidden" && n !== "visible" && e.scrollHeight >= e.clientHeight ? e : ir(e.parentElement);
}
function Ko(e) {
  let t = {
    top: 0,
    left: 0
  };
  if (!e)
    return t;
  let n = e.ownerDocument.defaultView;
  for (; n !== window.top; ) {
    var r;
    const s = (r = n) == null ? void 0 : r.frameElement;
    if (s) {
      var i, o;
      const c = s.getBoundingClientRect();
      t.top += c.top + ((i = c.scrollTop) != null ? i : 0), t.left += c.left + ((o = c.scrollLeft) != null ? o : 0);
    }
    n = n.parent;
  }
  return t;
}
function Xo(e, t) {
  const n = e.getBoundingClientRect();
  let r = n.y || n.top, i = n.bottom || r + n.height;
  if (t) {
    const s = t.getBoundingClientRect(), c = s.y || s.top, a = s.bottom || c + s.height;
    r = Math.max(r, c), i = Math.min(i, a);
  }
  const o = Math.max(i - r, 0);
  return {
    y: r,
    height: o
  };
}
function Go(e, t, n) {
  let {
    element: r,
    openingProperties: i
  } = t, o = !1, s, c;
  u();
  const a = () => r;
  function u() {
    n(4, i = [{
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      r: 0
    }]);
  }
  function d() {
    n(1, o = !1), w();
  }
  function h(y = 0, m = 0, R = 0, D = 0, K, W, X) {
    if (W) {
      const $ = [W, ...X || []];
      n(4, i = []);
      for (const A of $) {
        if (!A || $.indexOf(A) !== $.lastIndexOf(A))
          continue;
        const {
          y: F,
          height: L
        } = Xo(A, K), {
          x: V,
          width: N,
          left: ne
        } = A.getBoundingClientRect();
        $.some((Q) => {
          if (Q === A) return !1;
          const Y = Q.getBoundingClientRect();
          return V >= Y.left && V + N <= Y.right && F >= Y.top && F + L <= Y.bottom;
        }) || i.push({
          width: N + y * 2,
          height: L + y * 2,
          x: (V || ne) + R - y,
          y: F + D - y,
          r: m
        });
      }
    } else
      u();
  }
  function f(y) {
    w(), y.tour.options.useModalOverlay ? (_(y), g()) : d();
  }
  function g() {
    n(1, o = !0);
  }
  const b = (y) => {
    y.preventDefault();
  }, E = (y) => {
    y.stopPropagation();
  };
  function S() {
    window.addEventListener("touchmove", b, {
      passive: !1
    });
  }
  function w() {
    s && (cancelAnimationFrame(s), s = void 0), window.removeEventListener("touchmove", b, {
      passive: !1
    });
  }
  function _(y) {
    const {
      modalOverlayOpeningPadding: m,
      modalOverlayOpeningRadius: R,
      modalOverlayOpeningXOffset: D = 0,
      modalOverlayOpeningYOffset: K = 0
    } = y.options, W = Ko(y.target), X = ir(y.target), $ = () => {
      s = void 0, h(m, R, D + W.left, K + W.top, X, y.target, y._resolvedExtraHighlightElements), s = requestAnimationFrame($);
    };
    $(), S();
  }
  function O(y) {
    We[y ? "unshift" : "push"](() => {
      r = y, n(0, r);
    });
  }
  return e.$$set = (y) => {
    "element" in y && n(0, r = y.element), "openingProperties" in y && n(4, i = y.openingProperties);
  }, e.$$.update = () => {
    e.$$.dirty & /*openingProperties*/
    16 && n(2, c = zo(i));
  }, [r, o, c, E, i, a, u, d, h, f, g, O];
}
class Zo extends me {
  constructor(t) {
    super(), ge(this, t, Go, Jo, pe, {
      element: 0,
      openingProperties: 4,
      getElement: 5,
      closeModalOpening: 6,
      hide: 7,
      positionModal: 8,
      setupForStep: 9,
      show: 10
    });
  }
  get getElement() {
    return this.$$.ctx[5];
  }
  get closeModalOpening() {
    return this.$$.ctx[6];
  }
  get hide() {
    return this.$$.ctx[7];
  }
  get positionModal() {
    return this.$$.ctx[8];
  }
  get setupForStep() {
    return this.$$.ctx[9];
  }
  get show() {
    return this.$$.ctx[10];
  }
}
class Qo extends Ft {
  constructor() {
    super(), this.activeTour = void 0, jt(this);
  }
}
class es extends Ft {
  constructor(t = {}) {
    super(), this.trackedEvents = ["active", "cancel", "complete", "show"], this.classPrefix = void 0, this.currentStep = void 0, this.focusedElBeforeOpen = void 0, this.id = void 0, this.modal = void 0, this.options = void 0, this.steps = void 0, jt(this);
    const n = {
      exitOnEsc: !0,
      keyboardNavigation: !0
    };
    return this.options = Object.assign({}, n, t), this.classPrefix = Nn(this.options.classPrefix), this.steps = [], this.addSteps(this.options.steps), ["active", "cancel", "complete", "inactive", "show", "start"].map((i) => {
      ((o) => {
        this.on(o, (s) => {
          s = s || {}, s.tour = this, Se.trigger(o, s);
        });
      })(i);
    }), this._setTourID(t.id), this;
  }
  /**
   * Adds a new step to the tour
   * @param {StepOptions} options - An object containing step options or a Step instance
   * @param {number | undefined} index - The optional index to insert the step at. If undefined, the step
   * is added to the end of the array.
   * @return The newly added step
   */
  addStep(t, n) {
    let r = t;
    return r instanceof Mt ? r.tour = this : r = new Mt(this, r), U(n) ? this.steps.push(r) : this.steps.splice(n, 0, r), r;
  }
  /**
   * Add multiple steps to the tour
   * @param {Array<StepOptions> | Array<Step> | undefined} steps - The steps to add to the tour
   */
  addSteps(t) {
    return Array.isArray(t) && t.forEach((n) => {
      this.addStep(n);
    }), this;
  }
  /**
   * Go to the previous step in the tour
   */
  back() {
    const t = this.steps.indexOf(this.currentStep);
    this.show(t - 1, !1);
  }
  /**
   * Calls _done() triggering the 'cancel' event
   * If `confirmCancel` is true, will show a window.confirm before cancelling
   * If `confirmCancel` is a function, will call it and wait for the return value,
   * and only cancel when the value returned is true
   */
  async cancel() {
    if (this.options.confirmCancel) {
      const t = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
      let n;
      ve(this.options.confirmCancel) ? n = await this.options.confirmCancel() : n = window.confirm(t), n && this._done("cancel");
    } else
      this._done("cancel");
  }
  /**
   * Calls _done() triggering the `complete` event
   */
  complete() {
    this._done("complete");
  }
  /**
   * Gets the step from a given id
   * @param {number | string} id - The id of the step to retrieve
   * @return The step corresponding to the `id`
   */
  getById(t) {
    return this.steps.find((n) => n.id === t);
  }
  /**
   * Gets the current step
   */
  getCurrentStep() {
    return this.currentStep;
  }
  /**
   * Hide the current step
   */
  hide() {
    const t = this.getCurrentStep();
    if (t)
      return t.hide();
  }
  /**
   * Check if the tour is active
   */
  isActive() {
    return Se.activeTour === this;
  }
  /**
   * Go to the next step in the tour
   * If we are at the end, call `complete`
   */
  next() {
    const t = this.steps.indexOf(this.currentStep);
    t === this.steps.length - 1 ? this.complete() : this.show(t + 1, !0);
  }
  /**
   * Removes the step from the tour
   * @param {string} name - The id for the step to remove
   */
  removeStep(t) {
    const n = this.getCurrentStep();
    this.steps.some((r, i) => {
      if (r.id === t)
        return r.isOpen() && r.hide(), r.destroy(), this.steps.splice(i, 1), !0;
    }), n && n.id === t && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel());
  }
  /**
   * Show a specific step in the tour
   * @param {number | string} key - The key to look up the step by
   * @param {boolean} forward - True if we are going forward, false if backward
   */
  show(t = 0, n = !0) {
    const r = Ke(t) ? this.getById(t) : this.steps[t];
    r && (this._updateStateBeforeShow(), ve(r.options.showOn) && !r.options.showOn() ? this._skipStep(r, n) : (this.currentStep = r, this.trigger("show", {
      step: r,
      previous: this.currentStep
    }), r.show()));
  }
  /**
   * Start the tour
   */
  async start() {
    this.trigger("start"), this.focusedElBeforeOpen = document.activeElement, this.currentStep = null, this.setupModal(), this._setupActiveTour(), this.next();
  }
  /**
   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour
   * @param {string} event - The event name to trigger
   * @private
   */
  _done(t) {
    const n = this.steps.indexOf(this.currentStep);
    if (Array.isArray(this.steps) && this.steps.forEach((r) => r.destroy()), qo(this), this.trigger(t, {
      index: n
    }), Se.activeTour = null, this.trigger("inactive", {
      tour: this
    }), this.modal && this.modal.hide(), (t === "cancel" || t === "complete") && this.modal) {
      const r = document.querySelector(".shepherd-modal-overlay-container");
      r && (r.remove(), this.modal = null);
    }
    He(this.focusedElBeforeOpen) && this.focusedElBeforeOpen.focus();
  }
  /**
   * Make this tour "active"
   */
  _setupActiveTour() {
    this.trigger("active", {
      tour: this
    }), Se.activeTour = this;
  }
  /**
   * setupModal create the modal container and instance
   */
  setupModal() {
    this.modal = new Zo({
      target: this.options.modalContainer || document.body,
      props: {
        // @ts-expect-error TODO: investigate where styles comes from
        styles: this.styles
      }
    });
  }
  /**
   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step
   * @param {Step} step - The step to skip
   * @param {boolean} forward - True if we are going forward, false if backward
   * @private
   */
  _skipStep(t, n) {
    const r = this.steps.indexOf(t);
    if (r === this.steps.length - 1)
      this.complete();
    else {
      const i = n ? r + 1 : r - 1;
      this.show(i, n);
    }
  }
  /**
   * Before showing, hide the current step and if the tour is not
   * already active, call `this._setupActiveTour`.
   * @private
   */
  _updateStateBeforeShow() {
    this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour();
  }
  /**
   * Sets this.id to a provided tourName and id or `${tourName}--${uuid}`
   * @param {string} optionsId - True if we are going forward, false if backward
   * @private
   */
  _setTourID(t) {
    const n = this.options.tourName || "tour", r = t || Yn();
    this.id = `${n}--${r}`;
  }
}
const Se = new Qo(), or = typeof window > "u";
Se.Step = or ? ii : Mt;
Se.Tour = or ? oi : es;
const Jt = Mr(
  void 0
), ns = Jt.Consumer, rs = () => {
  const e = Fr(Jt);
  if (!e)
    throw new Error(
      "useShepherd must be used within a ShepherdJourneyProvider"
    );
  const { Shepherd: t } = e;
  return t;
}, is = ({
  children: e
}) => /* @__PURE__ */ Hr.jsx(Jt.Provider, { value: { Shepherd: Se }, children: e });
export {
  ns as JourneyMethods,
  Jt as ShepherdJourneyContext,
  is as ShepherdJourneyProvider,
  rs as useShepherd
};
